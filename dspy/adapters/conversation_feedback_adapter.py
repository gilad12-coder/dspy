from typing import List, Dict, Any
from dspy.signatures.signature import Signature
from dspy.adapters import ChatAdapter


class ConversationalFeedbackAdapter(ChatAdapter):
    """
    Adapter that injects feedback as conversation turns into the model inputs.
    Directly inherits from ChatAdapter.
    """

    def __init__(self,
        feedback_history: List[str] = None,
        attempt_outputs: List[str] = None,
        **kwargs
    ):
        """
        Initialize the adapter with feedback history and attempt outputs.

        Args:
            feedback_history: List of feedback strings from previous attempts
            attempt_outputs: List of prediction outputs from previous attempts
            **kwargs: Additional arguments to pass to ChatAdapter
        """
        super().__init__(**kwargs)
        self.feedback_history = feedback_history or []
        self.attempt_outputs = attempt_outputs or []

    def format(self,
       signature: Signature,
       demos: List[Dict[str, Any]],
       inputs: Dict[str, Any]
    ) -> List[Dict[str, Any]]:
        """
        Format messages with feedback history.

        Args:
            signature: The signature of the task.
            demos: List of demonstration examples.
            inputs: Input data for the current task.

        Returns:
            Formatted conversation history.

        High-Level Conversation Message Structure:
            1. **Initial System and Demo Messages:**
               - These messages are generated by the parent ChatAdapter and provide the initial system instructions,
                 context, and demonstration examples.
            2. **Original Final User Message:**
               - The last message from the parent is assumed to be the original user prompt. This message is temporarily removed.
            3. **Feedback Incorporation (If Feedback History Exists):**
               - If there are previous attempts:
                   a. **System Message Update:** If a system message exists and previous attempt outputs are present,
                      a note is appended to instruct the model to analyze errors and generate a revised response that avoids repeating mistakes.
                   b. **Assistant-User Pairs:** For each previous attempt, two messages are added:
                      - An assistant message containing the model's output from that attempt.
                      - A subsequent user message with the feedback corresponding to that attempt.
            4. **Final User Prompt:**
               - The original final user message (i.e. the task prompt) is re-added at the end to prompt the next attempt.
        """
        # Get the original messages, which include system, demos, and the final user message
        original_messages = super().format(signature, demos, inputs)
        # If there's no feedback history, return the original messages unchanged
        if not self.feedback_history:
            return original_messages
        # Assert that the last message is a user message (required for conversation structure)
        assert original_messages[-1]["role"] == "user", "Format error: Last message must be a user message for conversational feedback"
        # Initialize new_messages with all messages except the final user message
        # This preserves the system message and any demo pairs
        new_messages = original_messages[:-1]

        # Update the system message if there are previous attempts
        if new_messages and new_messages[0]["role"] == "system" and self.attempt_outputs:
            new_messages[0]["content"] += (
                "\n\nNote: If previous attempts contained errors as identified by the user, "
                "you are expected to analyze and understand these errors, and generate a revised response "
                "that avoids repeating the same mistakes. Please ensure that your response addresses all issues raised."
            )
        # Add previous attempts and their feedback after the demos
        for output, feedback in zip(self.attempt_outputs, self.feedback_history):
            # Add the previous attempt as an assistant message
            attempt_msg = {"role": "assistant", "content": output}
            new_messages.append(attempt_msg)
            # Add the feedback as a user message
            feedback_msg = {"role": "user", "content": feedback}
            new_messages.append(feedback_msg)
        # Add the final user message to prompt the next attempt
        final_user_message = original_messages[-1]
        new_messages.append({
            "role": "user",
            "content": final_user_message['content']
        })
        return new_messages